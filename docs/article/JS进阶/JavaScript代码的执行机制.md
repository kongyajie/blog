# JavaScript代码的执行机制

## 导读

作为前端开发者，我们少不了跟 JavaScript 打交道。

相信很多人跟我一样，都有类似的感受：

- 1、刚开始，JS入门时感觉很容易，立马就能上手，没有 C++ 或 Java 那么多类型限制，靠var、function 就能走遍天下
- 2、然而，随着使用的深入，会发现有一些很奇怪的事发生，比如，function 内 this 的指向跟预期不一样、var声明的变量值跟预期不一样等等
- 3、同时，在面试或者阅读一段代码判断输出结果时，全凭感觉和片面的猜测，脑海中并没有一个具体的执行流程画面

到达这个阶段，就会进入一个瓶颈，感觉平时的工作基本能完成，但是又感觉缺了点什么。

于是，开始想要彻底搞清楚 JS 的内部执行机制。

怎么办？

一般我们获取知识的途径无非

 - 最容易/省事：互联网搜索，百度、Google、知乎、掘金之。的确发现了很多不错的文章，有的还是牛人撰写的系统性介绍JS的专栏。不过，由于是第二手的资料，每位作者都有各自的切入点和理解，而且有时对于JS执行过程中的名词还有不同说法。比如对闭包的说法就有很多，又比如对执行上下文的理解，包含哪些部分也没有统一的介绍，这样更让读者更觉得混乱。
 - 最困难：研究第一手的资料。看书、ECMAScript标准、MDN、V8引擎。往往由于没有好的切入点或精力不够等原因，能坚持下来的人很少；
 - 最靠谱：购买付费课程，掘金小册、知乎live、极客时间等。优点是能开课的老师基本都有两把刷子，有些还是行业的领军人物，课程内容有保证；缺点是花钱，大部分课程都不算贵，几十块钱。个人认为想要深入学习某个领域，付费课程值得一试，当然前提是择优购买。

最终通过极客时间的《浏览器工作原理和实践》这门课，我得到了自己想要的，于是就有了这篇文章，希望它能让你有所收获。

本文将从JS引擎的角度详细介绍 JavaScript 的执行机制。

从一段代码开始：

```js
function bar() {
  var name = 'aaron';
  let test1 = 100;
  if (1) {
    let name = 'vera';
    console.log(test);
  }
}

function foo() {
  var name = 'aaron2';
  let test = 2;
  {
    let test = 3;
    bar();
  }
}

var name = 'aaron';
let age = 10;
let test = 1;
foo();
```

我们暂且不管打印结果如何，先看看代码执行的逻辑。

- 1、生成`全局执行上下文`，包含`变量环境`、`词法环境`、`outer指针`，并将它推入`调用栈`中；
- 2、执行全局`可执行代码`，执行赋值操作，接着调用 `foo` 函数；
- 3、生成`foo函数执行上下文`，同样包含`变量环境`、`词法环境`、`outer指针`，并将它推入`调用栈`中；
- 4、执行foo函数内`可执行代码`，执行赋值操作，并在`词法环境`中创建两个块变量区域；
- 5、生成`bar函数执行上下文`，并将它推入`调用栈`中；
- 6、执行bar函数内`可执行代码`，执行完毕后，将`bar函数执行上下文`出栈，并将返回值传递给foo函数;
- 7、执行foo函数剩余代码，执行完毕后，将`foo函数执行上下文`出栈；
- 8、执行全局剩余代码，执行完毕后，将`全局执行上下文`出栈；

整个过程就是这样，最终结果如下图所示：

![示意图](https://static001.geekbang.org/resource/image/25/a7/25053af5ae30c8be991fa14631cde0a7.png)

图中的数字即是变量搜索的顺序

另外要说明的是：
- outer 指针是遵循`词法作用域`的，所以其指向在函数声明时即确定了
- 变量在搜索时，若在当前执行上下`未命中，则会在其outer指针所指的执行上下文中搜索，以此类推，直到命中，或到达全局执行上下文结束


以上，就是JS代码执行流程的具体流程了，欢迎指正和补充~