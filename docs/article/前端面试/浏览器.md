# 浏览器

## 一、如何发展的？解决什么问题？- 历史

- 1990年 The WorldWideWeb browser（Nexus平台）
- 1993年 NCSA Mosaic
- 1994年 Netscape Navigator
- 1995年 Microsoft Internet Explorer
- 1996年 Opera
- 2003年，Apple Safari
- 2004年 Mozilla Firefox
- 2008年 Google Chrome
- 2015年 Microsoft Edge
- 2016年 Vivaldi

## 二、如何构成的？- 架构

### 背景知识

- 进程
  - 进程是cpu资源分配的最小单位（是能拥有资源和独立运行的最小单位）
  - IPC 进程间通讯 
- 线程
  - 线程是cpu调度的最小单位（线程是建立在进程的基础上的一次程序运行单位，一个进程中可以有多个线程）
- 协程

### 1、单进程浏览器时代

- 特点：所有页面都运行在一个主进程中（网络线程、页面线程、其他线程）
- IE6：单标签，一个页面一个窗口
- 缺点：不稳定、不流畅、不安全

### 2、多进程浏览器时代

结构：

- 1个浏览器主进程：负责界面显示、用户交互、子进程管理，同时提供存储等功能
- 1个GPU进程：最初是为了实现3D CSS的效果，后来网页和浏览器UI界面也采用GPU绘制
- 1个网络进程：负责页面的网络资源加载
- 多个渲染进程：将HTML、CSS、JavaScript转换为用户可以与之交互的网页
- 多个插件进程：负责插件的运行

优点：

- 稳定性：进程间相互隔离
- 流畅性：JS只影响当前的渲染进程；关闭页面，进程所占用的内存会被系统回收
- 安全性：安全沙箱

缺点：

- 更高的资源占用、更复杂的体系架构

### 3、未来面向服务的架构SOA

- 为了解决这些问题，在 2016 年，Chrome 官方团队使用“面向服务的架构”（Services Oriented Architecture，简称 SOA）的思想设计了新的 Chrome 架构。也就是说 Chrome 整体架构会朝向现代操作系统所采用的“面向服务的架构” 方向发展，原来的各种模块会被重构成独立的服务（Service），每个服务（Service）都可以在独立的进程中运行，访问服务（Service）必须使用定义好的接口，通过 IPC 来通信，从而构建一个更内聚、松耦合、易于维护和扩展的系统，更好实现 Chrome 简单、稳定、高速、安全的目标。如果你对面向服务的架构感兴趣，你可以去网上搜索下资料，这里就不过多介绍了。Chrome 最终要把 UI、数据库、文件、设备、网络等模块重构为基础服务，类似操作系统底层服务

### 4、浏览器的差异在哪里？

- 排版/渲染引擎：负责将标记内容、样式信息排版后输出至显示器或打印机
  - Chrome：Blink
  - Safari：Webkit
  - Mozilla：Gecko
  - Internet Explorer：Trident
  - Microsoft Edge：EdgeHTML
  - QQ浏览器/世界之窗/搜狗浏览器：Trident、Blink

- JS引擎：解释执行JS

  - Rhino，由Mozilla基金会管理，开放源代码，完全以Java编写。
  - **SpiderMonkey**，第一款JavaScript引擎，早期用于Netscape Navigator，现时用于Mozilla Firefox。
  - **V8**，开放源代码，由Google丹麦开发，是Google Chrome的一部分。
  - JavaScriptCore，开放源代码，用于Safari。
  - Chakra (JScript引擎)，用于Internet Explorer。
  - Chakra (JavaScript引擎)，用于Microsoft Edge。

- 浏览器User-Agent

  - 首部包含了一个特征字符串，用来让网络协议的对端来识别发起请求的用户代理软件的应用类型、操作系统、软件开发商以及版本号

    `User-Agent: Mozilla/<version> (<system-information>) <platform> (<platform-details>) <extensions>`

    `Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_7) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/93.0.4577.63 Safari/537.36`

  - 发展历程
    - 1、Netscape Navigator2.0 支持GIF，而Mosaic不支持，因此引入UA标识，告诉服务器有Mozilla标识时才发送GIF；
    - 2、IE出版，也支持GIF了，但是UA上没有Mozilla标识，于是微软也在UA上加上了Mozilla标识；
    - 3、Netscape在第一次浏览器大站中输给了IE，接着以MozillaFirefox重生，搞出了Gecko引擎，并在UA上加上了Gecko，Gecko开源后有许多其他浏览器基于它的代码二次开发，因此也都在UA上加上了Gecko。每一个都假装自己是Mozilla，每一个都使用了Gecko的代码。
    - 4、接着一帮搞Linux的人弄了个浏览器Konqueror，引擎叫KHTML，他们觉得KHTML和Gecko一样好，于是在UA上加上了（KHTML，like Gecko）
    - 5、Apple弄出了Safari，以KHTML为基础打造出Webkit，然后叫 AppleWebKit（KHTML，like Gecko）
    - 6、Google又基于Webkit搞出了Chrome，因此它为了伪装成safari，webkit伪装成KHTML，KHTML伪装成Gecko，最后所有的浏览器都伪装成 Mozilla。

  



## 三、如何动起来的？- 页面循环系统

### 概述

> 背景：渲染进程中的渲染主线程是单线程的,而它又要处理非常多的任务。
>
> 总体上：EventLoop 使用了事件循环+消息队列来实现

### 运行流程

![](https://oss-1252175178.cos.ap-shanghai.myqcloud.com/JS/%E6%B5%8F%E8%A7%88%E5%99%A8EventLoop.png)

![](https://oss-1252175178.cos.ap-shanghai.myqcloud.com/JS/%E6%B5%8F%E8%A7%88%E5%99%A8EventLoop%E6%B5%81%E7%A8%8B-%E5%BE%AE%E4%BB%BB%E5%8A%A1.png)

## 四、如何从URL到页面显示的？

- 网络请求阶段
  - 判断是URL还是关键字
  - DNS解析
  - 发送HTTP请求
  - 服务器处理
- 页面渲染阶段
  - 解析HTML（预解析、下载CSS/JS、执行JS）
  - 生成DOM
  - 生成CSSOM（计算样式Style）
  - 生成LayoutTree（计算几何布局，过滤不需要显示的元素如header/script标签、display:none等）
  - 生成图层树LayerTree（分层，从宏观上提升渲染效率）
  - 生成绘制列表

## 五、如何进行性能优化？

## 六、如何与服务器通讯？计算机网络

## 七、如何保证浏览器安全？

## 八、未来发展趋势

