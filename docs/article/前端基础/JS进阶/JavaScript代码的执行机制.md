# JavaScript代码的执行机制

## 导读

作为前端开发者，我们少不了跟 JavaScript 打交道。

相信很多人跟我一样，都有类似的感受：

- 1、刚开始，JS入门时感觉很容易，立马就能上手，没有 C++ 或 Java 那么多类型限制，靠var、function 就能走遍天下
- 2、然而，随着使用的深入，会发现有一些很奇怪的事发生，比如，function 内 this 的指向跟预期不一样、var声明的变量值跟预期不一样等等
- 3、同时，在面试或者阅读一段代码判断输出结果时，全凭感觉和片面的猜测，脑海中并没有一个具体的执行流程画面

到达这个阶段，就会进入一个瓶颈，感觉平时的工作基本能完成，但是又感觉缺了点什么。

于是，开始想要彻底搞清楚 **JS 的内部执行机制**。

怎么办？

通常我们获取知识的途径有下面几种：

 - 最方便：**互联网搜索**，百度、Google、知乎、掘金之。的确发现了很多不错的文章，有的还是牛人撰写的系统性介绍JS的专栏。不过，由于是第二手的资料，每位作者都有各自的切入点和理解，而且有时对于JS执行过程中的名词还有不同说法。比如对闭包的说法就有很多，又比如对执行上下文的理解，包含哪些部分也没有统一的介绍，这样更让读者更觉得混乱。
 - 最困难：**研究第一手的资料**。看书、ECMAScript标准、MDN、V8引擎。往往由于没有好的切入点或精力不够等原因，能坚持下来的人很少；
 - 最靠谱：**购买付费课程**，掘金小册、知乎live、极客时间等。优点是能开课的老师基本都有两把刷子，有些还是行业的领军人物，课程内容有保证；缺点是花钱，大部分课程都不算贵，几十块钱。个人认为想要深入学习某个领域，付费课程值得一试，当然前提是择优购买。

最终通过极客时间的《浏览器工作原理和实践》这门课，我得到了自己想要的，于是就有了这篇文章，希望它能对你有所帮助。

本文将从JS引擎的角度详细介绍 JavaScript 的执行机制。

## 执行过程

从一段代码开始：

```js
function bar() {
  var name = 'aaron';
  let test1 = 100;
  if (1) {
    let name = 'vera';
    console.log(test);
  }
}

function foo() {
  var name = 'aaron2';
  let test = 2;
  {
    let test = 3;
    bar();
  }
}

var name = 'aaron';
let age = 10;
let test = 1;
foo();
```

我们暂且不管打印结果如何，先看看引擎如何执行这段代码：

- 0、js引擎在运行代码时，都会经历两个步骤：编译阶段、执行阶段。编译阶段创建执行上下文、可执行代码，执行阶段即执行可执行代码。
- 1、生成`全局执行上下文`，包含`变量环境`、`词法环境`、`outer指针`，并将它推入`调用栈`中；
- 2、执行全局`可执行代码`，执行赋值操作，接着调用 `foo` 函数；
- 3、生成`foo函数执行上下文`，同样包含`变量环境`、`词法环境`、`outer指针`，并将它推入`调用栈`中；
- 4、执行foo函数内`可执行代码`，执行赋值操作，并在`词法环境`中创建两个块变量区域（let const变量）；
- 5、生成`bar函数执行上下文`，并将它推入`调用栈`中；
- 6、执行bar函数内`可执行代码`，执行完毕后，将`bar函数执行上下文`出栈，并将返回值传递给foo函数;
- 7、执行foo函数剩余代码，执行完毕后，将`foo函数执行上下文`出栈；
- 8、执行全局剩余代码，执行完毕后，将`全局执行上下文`出栈；

以上即是对整个过程的模拟，最终结果如下图所示：

![示意图](https://static001.geekbang.org/resource/image/25/a7/25053af5ae30c8be991fa14631cde0a7.png)

图中的数字即是变量搜索的顺序

## 名词解释

### 变量提升
遇到变量声明或函数声明时，将声明的变量名加入到执行上下文的变量环境中，这样可执行代码执行时，即可引用执行上下文中的变量了。

### 调用栈
- js代码的运行时结构，用来辅助执行上下文的出栈入栈
- 在Chrome的开发者工具中可以查看到，在要查看的代码行 `debugger `或者 `console.trace()`
- 递归调用太多时，可能出现栈溢出

### 执行上下文
- 可执行代码的辅助环境（物理上的），包含了变量环境（var变量、outer指针、this）、词法环境（let、const变量），以及闭包。

### 作用域
- 变量的生存环境

### 作用域链
- 由词法作用域确定，它反映了代码的结构（声明时确定）
- outer 指针即是作用域链的钩子

### outer
- outer 指针是遵循`词法作用域`的，所以其指向在函数声明时即确定了
- 变量在搜索时，若在当前执行上下`未命中，则会在其outer指针所指的执行上下文中搜索，以此类推，直到命中，或到达全局执行上下文结束

### 闭包
- 定义：内部函数引用外部函数的变量的集合
- 作用：1、保护私有变量；2、维持内部私有变量的状态
- 查看：Local => Closure => Global

### this
- this 在执行上下文中
- 全局执行上下文中的this，即 window；函数执行上下文中的this，即是对象本身
- this缺陷：1、this不会继承外部函数的this；2、普通函数this默认执行window（非严格模式下）；3、对象中函数调用this，即是对象本身
- 解决方案：self、箭头函数、call/apply/bind

## JavaScript的语言类型

## JavaScript的数据类型

## JavaScript的内存模型

## 垃圾回收

## V8引擎的工作原理

1、编译型语言和解释型语言

首先，根据语言的执行流程不同，可以把语言划分为编译型语言和解释型语言。

编译型语言在程序执行之前，编译之后会直接保留机器能读懂的二进制文件，这样每次运行程序时，都可以直接运行二进制文件，而无需重新编译。如C/C++、GO等。

而解释型语言在每次运行时都需要通过解释器对程序进行动态解释和执行。比如Python、JavaScript等。

2、V8是如何执行一段 JavaScript 代码的？

- 1）编译器通过词法分析和语法分析，生成语法分析树（AST）和执行上下文
- 2）解释器根据AST生成字节码（最初无字节码时，使用机器码很ok，不过随着Chrome在手机上的普及，手机内存的占用问题暴露了，机器码太占内存，所以引入字节码）
- 3）解释器逐条执行字节码。若发现有热点代码（HotSpot），则把该段代码的字节码编译为更高效的机器码，下次执行这段代码时，只需执行机器码即可，大大提升代码的执行效率。这种字节码配合解释器和编译器的技术被称为“即时编译（JIT）”，Java和Python的虚拟机也都是基于这种技术实现的。

3、JIT的工作过程（如图）

小结：了解V8引擎的工作原理，有助于我们了解代码执行的过程，同时，对于JavaScript的性能优化也有帮助。

以上，就是JS代码执行流程的具体流程了，欢迎指正和补充~