# 防抖和节流
## 防抖

> 概念：触发高频时间后n秒内函数只会执行一次,如果n秒内高频时间再次触发,则重新计算时间。
> 可以理解为游戏中法师的施法前摇，1s的前摇如果没有被打断，则施法成功；如果1s内被打断，则重新开始计时。

```html
<input type="text" id="inputT">
```

```js
let inputB = document.getElementById('inputB');

let debounceAjax = debounce(ajax, 1000);

inputB.addEventListener("keyup", (e) => {
  debounceAjax(e.target.value);
});

function debounce(fn, delay) {
  let timer = null;
  return (arg) => {
    clearTimeout(timer);
    timer = setTimeout(() => {
      fn(arg);
    }, delay)
  }
}

function ajax(content) {
  console.log('ajax request', content);
}
```

## 节流

> 概念：高频时间触发,但n秒内只会执行一次,所以节流会稀释函数的执行频率。
> 可以理解为FPS游戏的射速，就算一直按着鼠标射击，也只会在规定射速内射出子弹。

```html
<input type="text" id="inputT">
```

```js
let inputT = document.getElementById("inputT");

let throttleAjax = throttle(ajax, 1000);

inputT.addEventListener("keyup", (e) => {
  throttleAjax(e.target.value); // 这里不能直接用throttle(ajax, 1000)(e.target.value)？
})

function throttle(fn, delay) {
  let lastTime = null;
  return (arg) => {
    let nowTime = Date.now();
    if (!lastTime || nowTime - lastTime > delay) { // 未触发过 或 上次触发到现在超过延时
      lastTime = nowTime;
      fn(arg);
    }
  }
}

function ajax(content) {
  console.log('Ajax request', content);
}
```
## 相同点

- 目的都是，降低回调执行频率。节省计算资源。

## 不同点：

- 函数防抖，在一段连续操作结束后，处理回调，利用clearTimeout 和 setTimeout实现。函数节流，在一段连续操作中，每一段时间只执行一次，频率较高的事件中使用来提高性能。
- 函数防抖关注一定时间连续触发的事件只在最后执行一次，而函数节流侧重于一段时间内只执行一次。

## 函数防抖的应用场景
连续的事件，只需触发一次回调的场景有：

- 搜索框搜索输入。只需用户最后一次输入完，再发送请求
- 手机号、邮箱验证输入检测
- 窗口大小Resize。只需窗口调整完成后，计算窗口大小。防止重复渲染。

## 函数节流的应用场景
间隔一段时间执行一次回调的场景有：

- 滚动加载，加载更多或滚到底部监听
- 谷歌搜索框，搜索联想功能
- 高频点击提交，表单重复提交


## 练习：使用纯JS模拟

快速请求，连续发送了5个相同的api，这样容易对服务器造成较大压力

```js
// 模拟api请求
function ajax(api) {
    console.log(api + 'ajax send')
}
// 模拟快速提交
for (let i = 1; i < 5; i++) {
    ajax('/user');
}
```

使用节流解决：

```js
// 节流
// 效果：一定时间间隔内，只调用一次fn
let lastTime = null
function throttle(fn, wait) {
    return (args) => {
        if (!lastTime || Date.now() - lastTime >= wait) {
            fn(args)
            lastTime = Date.now()
        }
    }
}

let throttleAjax = throttle(ajax, 1000);

// 测试
for (let i = 1; i < 5; i++) {
    setTimeout(() => {
        console.log(i)
        throttleAjax('/user')
    }, 500 * i)
}
```

使用防抖解决：

```js

// 防抖
function debounce(fn, wait) {
    let timer = null
    return (args) => {
        clearTimeout(timer)
        timer = setTimeout(() => {
            fn(args)
        }, wait)
    }
}
let debounceAjax = debounce(ajax,1000)

// 测试
for (let i = 1; i < 5; i++) {
    setTimeout(() => {
        console.log(i)
        debounceAjax('/user')
    }, 500 * i)
    
}
```

## 参考资料
- [7分钟理解JS的节流、防抖及使用场景](https://juejin.cn/post/6844903669389885453)
- [CodePen](https://codepen.io/RealAaron/pen/JjdOxEz?editors=0010)
- [Debouncing and Throttling Explained Through Examples](https://css-tricks.com/debouncing-throttling-explained-examples/)