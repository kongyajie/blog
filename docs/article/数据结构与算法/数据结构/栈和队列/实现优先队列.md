# 实现优先队列

## 描述

请设计一个可以指定优先级的任务队列 

1. 优先级范围是 0~100 
2. 高优先级的任务总是被先执行 
3. 支持设置队列的超时时间 
4. 每个任务都是一个返回 promise 的 function

## 思路

## 代码

（待验证）

```js
class TaskQueue {
  construtor(timeout) {
    this.queue = [];

    this.timeout = timeout;
  }

  start() {
    // 从头到尾依次执行队列中的任务
    // 前一个任务完成或超时，才开启下一个任务
    // 最终返回一个包含执行结果的promise

    async function excute(task) {
      return new Promise((resolve, reject) => {
        let p = task();

        let isTimeout = false;
        let timer = setTimeout(() => {
          isTimeout = true;
          resolve('timeout');
        }, this.timeout);

        p.then(res => {
          !isTimeout && resolve(res) && clearTimeout(timer);
        }, err => {
          !isTimeout && resolve(new Error(err) && clearTimeout(timer))
        })
      })
    }

    return new Promise((resolve, reject) => {

      let result = [];

      if (this.queue.length > 0) {
        let task = this.queue.shift(); // 取出队头任务
        let res = await excute(task); // 执行任务并返回结果
        result.push(res); // 将任务结果添加到结果列表中
      }

      resolve(result);
    })
  }

  add(task, priority = 0) {
    // 添加到队列
    this.queue.push({
      task,
      priority
    });

    // 按优先级排序
    this.queue.sort((a,b) => {
      b.priority - a.priority;
    })
  }
}

let queue = new TaskQueue(1000);

let task1 = () => {
  return new Promise((resolve, reject) => {
    conosle.log(1);
    resolve(1)
  })
}

let task2 = () => {
  return new Promise((resolve, reject) => {
    setTimeout(() => {
      conosle.log(2);
      resolve(2)
    }, 1500)
  })
}

let task3 = () => {
  return new Promise((resolve, reject) => {
    conosle.log(3);
    resolve(3)
  })
}

queue.add(task1);
queue.add(task2);
queue.add(task3, 1);

let p = queue.start();
p.then(res => console.log(res));
```


## 参考
[js实现任务（promise任务）队列](https://blog.csdn.net/XIAOLONGJUANFENG/article/details/113058280)
